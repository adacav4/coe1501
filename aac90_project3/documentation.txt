Adarsh Cavale | aac90 | Project 3
Documentation

In my implementation, I have 4 separate priority queues and 2 DLB's as a symbol tables. I have a priority queue for both general car prices and general car mileages (for all cars). Then I have a priority queue for specific make/model prices and another for specific make/model mileages. These are created for every different make and model, and is used to compare prices and mileages for a specific make and model. 

The Node class is used in MakeModelDLB. It has a bunch of setters and getters for accessing and changing attributes of the MakeModelDLB node like the value, the child, the sibling, and the associated priority queue. I store the priority queue of the specific make and model in the terminal node of the MakeModelDLB node for easy access to the different cars for that make and model.

The Car class is used to act as a car object. It stores the price, mileage, make, model, and color. And since we are using indexable priority queues backed by a heap, I specify the heap index for both the general price and mileage and the specific make and model price and mileage. I have setters and getters for VIN, make, model, color, price, mileage,  and all 4 indexes. I also have a printCar method that returns a car stat statement, so when a car is retrieved, it is easy to print.

The VINNode class is used in CarDLB. VINNode has many of the same attributes as Node, but it stores an instance of a Car object. VINNode has setters and getters for val, child, sibling, and Car (setCar and getCar). This class is meant for the car object to be stored at the end of the VIN (the string that is stored in the DLB).

In CarDLB, I store cars in a DLB (using the VIN of the car as the input string) for easy access. Since finding an element in a DLB is O(1), this does not affect the overall program runtime in anyway. This method is mainly used to retrieve the car when passing a specific VIN (along with the standard methods insert, remove, and exists, which are also used in the main driver program).

In MakeModelDLB, I use a DLB to store the different makes and models entered in the program. The stored string is the concatenated make and model. This method has the standard DLB methods like insert and exists. This DLB is meant to increase the dynamic nature of the program. Since you can technically enter as many makes and models as you want, this class serves as a great way to organize what and however many make and model combinations the user was to enter. 

In CarPriorityQueue, I used a lot of the code from Dr. Farnan's website and adapted it to fit the needs of my program. This is mainly used to act as the basis of all the priority queues in the program. I initialized the number of elements, the heap array, and two special fields: the pqType and the specMakeModel. pqType is a char used to indicate whether the user wants to access/update the prices (p) or mileages (m) priority queue. And the specMakeModel is used to indicate to update the specific make and model priority queues. A lot of the helper functions were used from the textbook and were mainly adapted to store Car objects and to access and edit them by indexing through the heap.

In PQGarage, I initialized 2 priority queues stated in the first paragraph to store the prices and the mileages for all cars added. Then, for each make and model, I dynamically create a priority queue for its price and for its mileage. I have the standard methods like insert, and remove. Then I have a getters that get the lowest price and mileage car for both all cars and specific makes and models (4 different getMin() methods). I also have methods to update the price and the mileage of a car (separately). These update cars in both the general priority queues and the specific make and model priority queues. I also update the CarPriorityQueue and MakeModelDLB with every change (insert, remove, update) to a car in the database.

The main driver program, CarTracker, is mainly just supporting the menu on the terminal. I have wrapper functions for methods like add, remove, update, retrieve min price (both for all cars and for specific make and models), and retrieve min mileage (both for all cars and for specific make and models). I do a lot of error, exception and input checking to see if the prices and mileages entered are numbers, and if the user entered a menu choice incorrectly. When adding, removing, or updating, I make sure to update all the priority queues and DLB's (when necessary) in order to keep the database up to date. 